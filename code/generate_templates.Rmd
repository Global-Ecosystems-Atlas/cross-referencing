---
title: "Generate cross-reference table templates"
output: html
---

# Introduction
This file takes information from the main database and generates templates for the IUCN crosswalk tables. It uses the `data_review` sheet from the GEA Google Sheet, which contains metadata about datasets that have been reviewed and passed the GEA criteria.

```{r}
# Load required libraries
library(glue)
library(readxl)  #for reading excel files)
library(googlesheets4)
library(tidyverse)  #for data wrangling etc
getwd()
rm(list=ls())
```

# Load main database/catalogue
Note this is for datasets that have moved to GEA_pass
```{r}
catalogue <- read_sheet("https://docs.google.com/spreadsheets/d/1P-xus66mTxY-9-a8jZgzwh3KVlL2Yvh6HzJ8rbmT1bY/edit?gid=396521023#gid=396521023", 
                        sheet = "Data_Review_MASTER", trim_ws = TRUE, col_types = "c")
```


# Subset source data
```{r}
source_data <- catalogue |> 
  # mutate(
  #   GEA_pass = case_when(
  #     map_lgl(GEA_pass, ~ identical(.x, TRUE)) ~ TRUE,
  #     map_lgl(GEA_pass, ~ identical(.x, FALSE)) ~ FALSE,
  #     TRUE ~ NA   # catches "REVIEW" and NULL
  #   )
  # ) |>
  filter(GEA_pass == TRUE)
```

# Can also subset to just REVIEW for checking
```{r}
data_review <- catalogue |> 
    filter(GEA_pass == "REVIEW")
```

```{r}
#write_csv(data_review, "../data/data_review.csv")
```


# Need EFG list to make wide IUCN template crosswalk tables
```{r}
efg_codes <- read_xlsx("../data/EFG_codes.xlsx") |> 
  pull(1) |> 
  unique() |> 
  as.character()
```


# Generate templates for membership matrix templates
```{r}
# Create directory if it doesn't exist
output_dir <- "../tables/membership-matrix-templates" 
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}


source_data |>
  mutate(n_map_classes = as.integer(n_map_classes)) |>  # Ensure n_map_classes is integer
  filter(!is.na(n_map_classes) & n_map_classes > 0) |>  # Only datasets with n_map_classes
  group_by(data_id_code) |>
  group_split() |>
  walk(function(df) {
    
    data_id <- unique(df$data_id_code)
    source_id <- if ("Source_ID" %in% names(df)) unique(df$Source_ID) else ""
    data_type <- if ("data_type" %in% names(df)) unique(df$data_type) else ""
    
    # Build tibble blocks for each band_layer_name
    tbl <- df |>
      rowwise() |>
      mutate(blank_block = list({
        n <- n_map_classes
        tibble(
          crossref_date = "",
          crossref_by = "", 
           # Source_ID,
           # data_id_code,
           # #data_type, 
           # band_layer_name,
           # in_class_field_name, 
           # in_class_value, 
           # in_class_description, 
           # in_class_description_detail,
          #entry_date = "",
          Source_ID = source_id,
          data_id_code = data_id,
          #data_type = "",
          #crosswalked_by = "",
          #status = "",
          #review_needed = "",
          #reviewed = "",
          #review_by = "",
          band_layer_name = rep(band_layer_name, n),
          in_class_field_name = "",
          in_class_value = "",
          in_class_description = "",
          in_class_description_detail = ""
        ) |>
          bind_cols(
            as_tibble(matrix("",
                             nrow = n,
                             ncol = length(efg_codes),
                             dimnames = list(NULL, efg_codes)))
          )
      })) |>
      pull(blank_block) |>
      bind_rows()
    
    # Create subfolder for each data_id
    subfolder <- file.path(output_dir, data_id)
    if (!dir.exists(subfolder)) {
      dir.create(subfolder, recursive = TRUE)
    }
    
    # Define save path
    save_path <- file.path(subfolder, glue("{data_id}_membmat_template.csv"))
    
    
    # Don't overwrite existing files
    if (!file.exists(save_path)) {
      write_csv(tbl, save_path)
    } else {
      message(glue("File {data_id}_mm_template.csv already exists. Skipping."))
    }
  })

```





